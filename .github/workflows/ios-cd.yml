name: iOS CD

on:
  push:
    branches:
      - main
  pull_request:
    types: [opened, synchronize, reopened, ready_for_review]

concurrency:
  group: ios-cd-${{ github.ref }}
  cancel-in-progress: true

env:
  # set APP_VARIANT based on branch (production for main, preview for PRs)
  APP_VARIANT: ${{ github.ref == 'refs/heads/main' && 'production' || 'preview' }}

jobs:
  # only run on native: commits or manual triggers
  check-trigger:
    runs-on: ubuntu-latest
    outputs:
      should-run: ${{ steps.check.outputs.should-run }}
    steps:
      - name: Check if should run
        id: check
        run: |
          if [[ "${{ github.event_name }}" == "workflow_dispatch" ]]; then
            echo "should-run=true" >> $GITHUB_OUTPUT
          elif [[ "${{ github.event.head_commit.message }}" == *"native:"* ]] || \
               [[ "${{ github.event.pull_request.title }}" == *"native:"* ]]; then
            echo "should-run=true" >> $GITHUB_OUTPUT
          else
            echo "should-run=false" >> $GITHUB_OUTPUT
          fi

  build-and-deploy:
    needs: check-trigger
    if: needs.check-trigger.outputs.should-run == 'true' && github.event.pull_request.draft != true
    # use warpbuild macos runner for faster builds (16 cores, 32GB RAM)
    runs-on: warp-macos-15-arm64-6x
    timeout-minutes: 60
    env:
      # select bundle id based on variant
      IOS_BUNDLE_ID: ${{ github.ref == 'refs/heads/main' && secrets.IOS_BUNDLE_ID_PRODUCTION || secrets.IOS_BUNDLE_ID_PREVIEW }}
    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          fetch-depth: 0  # fetch full history for changelog generation

      - name: Select Xcode
        run: |
          XCODE_VERSION=$(cat .xcode-version 2>/dev/null || echo "16.0")
          echo "Selecting Xcode $XCODE_VERSION"
          sudo xcode-select -s "/Applications/Xcode_${XCODE_VERSION}.app/Contents/Developer" || \
          sudo xcode-select -s "/Applications/Xcode.app/Contents/Developer"
          xcodebuild -version

      - name: Install
        uses: ./.github/actions/install

      - name: Write Public Env
        env:
          PUBLIC_ENV: ${{ vars.PUBLIC_ENV }}
        run: echo "${PUBLIC_ENV}" >> .env

      - name: Generate Native Fingerprint
        id: fingerprint
        run: |
          # generate expo fingerprint for native code - used for cache key
          fingerprint=$(bunx @expo/fingerprint . --platform ios 2>/dev/null | tail -1 || echo "no-fingerprint-${{ github.sha }}")
          echo "hash=$fingerprint" >> $GITHUB_OUTPUT
          echo "Native fingerprint: $fingerprint"

      - name: Cache iOS Native Build
        id: cache-ios
        uses: actions/cache@v4
        with:
          path: |
            ios/
            ci_build/
          key: ios-native-${{ steps.fingerprint.outputs.hash }}-${{ env.APP_VARIANT }}

      - name: Prebuild iOS
        if: steps.cache-ios.outputs.cache-hit != 'true'
        run: bun run native:prebuild --platform ios --no-install
        env:
          APP_VARIANT: ${{ env.APP_VARIANT }}

      - name: Pod Install
        if: steps.cache-ios.outputs.cache-hit != 'true'
        run: |
          # enable RN 0.81 precompiled builds for faster compilation
          RCT_USE_RN_DEP=1 RCT_USE_PREBUILT_RNCORE=1 pod install --project-directory=ios

      - name: Detect Xcode Project
        id: detect-project
        run: |
          # find the .xcworkspace in ios/ (created by pod install)
          workspace=$(find ios -maxdepth 1 -name "*.xcworkspace" -type d | head -1)
          if [ -z "$workspace" ]; then
            echo "Error: No .xcworkspace found in ios/"
            ls -la ios/
            exit 1
          fi
          workspace_name=$(basename "$workspace" .xcworkspace)
          echo "workspace=$workspace" >> $GITHUB_OUTPUT
          echo "scheme=$workspace_name" >> $GITHUB_OUTPUT
          echo "Found workspace: $workspace, scheme: $workspace_name"

      - name: Build Archive
        if: steps.cache-ios.outputs.cache-hit != 'true'
        timeout-minutes: 40
        env:
          SCHEME: ${{ steps.detect-project.outputs.scheme }}
          WORKSPACE: ${{ steps.detect-project.outputs.workspace }}
        run: |
          set -o pipefail

          # skip metro bundling during native build - we'll bundle JS separately
          # this file is sourced by the react-native xcode build phase (in ios/ folder)
          echo "export SKIP_BUNDLING=1" > ios/.xcode.env.updates

          # use xcodebuild with less verbose output but without xcpretty which can hang
          xcrun xcodebuild \
            -scheme "$SCHEME" \
            -workspace "$WORKSPACE" \
            -configuration Release \
            -sdk iphoneos \
            -destination "generic/platform=iOS" \
            -derivedDataPath ci_build \
            -archivePath ci_build/app.xcarchive \
            CODE_SIGNING_ALLOWED=NO \
            -quiet \
            archive
          echo "Archive completed successfully"

      - name: Verify Archive Exists
        run: |
          if [ ! -d "ci_build/app.xcarchive" ]; then
            echo "Error: Archive not found at ci_build/app.xcarchive"
            exit 1
          fi
          echo "Archive found: $(du -sh ci_build/app.xcarchive)"

      - name: Build JS Bundle
        env:
          SCHEME: ${{ steps.detect-project.outputs.scheme }}
          WORKSPACE: ${{ steps.detect-project.outputs.workspace }}
        run: |
          # find the app inside the archive
          app_location="$(find ci_build/app.xcarchive/Products/Applications -name "*.app" | head -1)"
          echo "App location: $app_location"

          # get PODS_ROOT from xcode build settings (needed for hermesc)
          PODS_ROOT="$(xcrun xcodebuild -workspace "$WORKSPACE" -scheme "$SCHEME" -configuration Release -showBuildSettings | grep '^\s*PODS_ROOT = ' | head -1 | sed 's/.*= //')"
          echo "PODS_ROOT: $PODS_ROOT"

          # bundle JS using expo export:embed (uses Expo's Metro config, bypasses vxrn issues)
          bunx expo export:embed \
            --platform ios \
            --entry-file index.js \
            --bundle-output "$app_location/main.jsbundle" \
            --assets-dest "$app_location" \
            --dev false \
            --reset-cache \
            --bytecode

          echo "Bundle created at: $app_location/main.jsbundle"
          ls -la "$app_location/main.jsbundle" || echo "Warning: bundle file not found"

      - name: Generate Changelog
        id: changelog
        uses: ./.github/actions/generate-changelog

      - name: Create Keychain
        id: keychain
        run: |
          keychain_name="ci-$(openssl rand -hex 6)"
          keychain_password="$(openssl rand -base64 24)"

          security create-keychain -p "$keychain_password" "$keychain_name"
          security unlock-keychain -p "$keychain_password" "$keychain_name"
          security set-keychain-settings -t 3600 -l "$keychain_name"

          # add to search list
          security list-keychains -d user -s "$keychain_name" $(security list-keychains -d user | tr -d '"')

          echo "keychain-name=$keychain_name" >> $GITHUB_OUTPUT
          echo "keychain-password=$keychain_password" >> $GITHUB_OUTPUT

      - name: Install Fastlane
        run: |
          # always install latest fastlane for match compatibility
          gem install fastlane --no-document
          fastlane --version

      - name: Install Apple WWDR Certificate
        run: |
          # download and install Apple WWDR (Worldwide Developer Relations) intermediate certificates
          # these are required to validate developer certificates
          curl -sL https://www.apple.com/certificateauthority/AppleWWDRCAG3.cer -o /tmp/AppleWWDRCAG3.cer
          security import /tmp/AppleWWDRCAG3.cer -k ${{ steps.keychain.outputs.keychain-name }} -T /usr/bin/codesign -T /usr/bin/security
          rm /tmp/AppleWWDRCAG3.cer

      - name: Sync Code Signing
        id: signing
        env:
          APPLE_CODE_SIGNING_GIT_URL: ${{ secrets.APPLE_CODE_SIGNING_GIT_URL }}
          APPLE_CODE_SIGNING_GIT_SSH_KEY: ${{ secrets.APPLE_CODE_SIGNING_GIT_SSH_KEY }}
          APPLE_CODE_SIGNING_GIT_PASSPHRASE: ${{ secrets.APPLE_CODE_SIGNING_GIT_PASSPHRASE }}
          KEYCHAIN_NAME: ${{ steps.keychain.outputs.keychain-name }}
          KEYCHAIN_PASSWORD: ${{ steps.keychain.outputs.keychain-password }}
        run: |
          rm -rf .apple-signing

          # write ssh key to temp file with proper permissions
          # GitHub secrets stored the key with literal backslash-n characters
          # Try multiple replacements: \\n, \n, and check what we're actually getting
          ssh_key_file=$(mktemp)

          # First, write raw key to see what format it is
          echo "$APPLE_CODE_SIGNING_GIT_SSH_KEY" > "${ssh_key_file}.raw"
          echo "Raw key size: $(wc -c < "${ssh_key_file}.raw")"
          echo "Raw key lines: $(wc -l < "${ssh_key_file}.raw")"
          echo "Raw key contains backslash-n: $(grep -c '\\n' "${ssh_key_file}.raw" || echo '0')"

          # Try using printf with %b which interprets escape sequences
          printf '%b' "$APPLE_CODE_SIGNING_GIT_SSH_KEY" > "$ssh_key_file"
          echo "" >> "$ssh_key_file"
          chmod 600 "$ssh_key_file"

          # debug: show key file info (not content, just structure)
          echo "Key file line count: $(wc -l < "$ssh_key_file")"
          echo "Key file first 10 chars: $(head -c 10 "$ssh_key_file" | od -c)"
          echo "Key contains PRIVATE KEY: $(grep -c 'PRIVATE KEY' "$ssh_key_file" || echo '0')"

          MATCH_PASSWORD="$APPLE_CODE_SIGNING_GIT_PASSPHRASE" fastlane match appstore \
            --readonly \
            --skip_certificate_matching true \
            --git_url "$APPLE_CODE_SIGNING_GIT_URL" \
            --git_branch match \
            --git_private_key "$ssh_key_file" \
            --keychain_name "$KEYCHAIN_NAME" \
            --keychain_password "$KEYCHAIN_PASSWORD" \
            --output_path .apple-signing \
            --app_identifier "$IOS_BUNDLE_ID" \
            --verbose true

          # cleanup ssh key
          rm -f "$ssh_key_file"

          # extract profile info
          profile=$(find .apple-signing -name "*.mobileprovision" | head -1)
          profile_name=$(security cms -D -i "$profile" | plutil -extract Name raw -o - -)
          team_id=$(security cms -D -i "$profile" | plutil -extract TeamIdentifier.0 raw -o - -)

          echo "profile-name=$profile_name" >> $GITHUB_OUTPUT
          echo "team-id=$team_id" >> $GITHUB_OUTPUT

          # allow code signing without prompts
          security set-key-partition-list -S apple-tool:,apple: -s -k "$KEYCHAIN_PASSWORD" "$KEYCHAIN_NAME"

      - name: Get App Info
        id: app-info
        run: |
          archive_path="ci_build/app.xcarchive"
          app_path=$(find "$archive_path/Products/Applications" -name "*.app" | head -1)

          bundle_id=$(/usr/libexec/PlistBuddy -c "Print :CFBundleIdentifier" "$app_path/Info.plist")
          version=$(/usr/libexec/PlistBuddy -c "Print :CFBundleShortVersionString" "$app_path/Info.plist")

          echo "app-path=$app_path" >> $GITHUB_OUTPUT
          echo "archive-path=$archive_path" >> $GITHUB_OUTPUT
          echo "bundle-id=$bundle_id" >> $GITHUB_OUTPUT
          echo "version=$version" >> $GITHUB_OUTPUT

      - name: Get Build Number
        id: build-number
        env:
          APP_STORE_CONNECT_API_KEY_ID: ${{ secrets.APP_STORE_CONNECT_API_KEY_ID }}
          APP_STORE_CONNECT_API_KEY_ISSUER_ID: ${{ secrets.APP_STORE_CONNECT_API_KEY_ISSUER_ID }}
          APP_STORE_CONNECT_API_KEY_P8: ${{ secrets.APP_STORE_CONNECT_API_KEY_P8 }}
          TEAM_ID: ${{ steps.signing.outputs.team-id }}
          BUNDLE_ID: ${{ steps.app-info.outputs.bundle-id }}
          VERSION: ${{ steps.app-info.outputs.version }}
        run: |
          api_key="{ \"key_id\": \"$APP_STORE_CONNECT_API_KEY_ID\", \"issuer_id\": \"$APP_STORE_CONNECT_API_KEY_ISSUER_ID\", \"key\": $(echo "$APP_STORE_CONNECT_API_KEY_P8" | jq -Rs .) }"

          latest=$(NO_COLOR=1 FASTLANE_ITC_TEAM_ID="$TEAM_ID" FASTLANE_HIDE_TIMESTAMP=true fastlane run \
            latest_testflight_build_number \
            app_identifier:"$BUNDLE_ID" \
            version:"$VERSION" \
            api_key:"$api_key" \
            | grep "Result:" | awk '{print $2}' || echo "0")

          next=$((10#${latest:-0} + 1))
          echo "build-number=$next" >> $GITHUB_OUTPUT

      - name: Update Build Number
        env:
          APP_PATH: ${{ steps.app-info.outputs.app-path }}
          ARCHIVE_PATH: ${{ steps.app-info.outputs.archive-path }}
          BUILD_NUMBER: ${{ steps.build-number.outputs.build-number }}
        run: |
          /usr/libexec/PlistBuddy -c "Set :CFBundleVersion $BUILD_NUMBER" "$APP_PATH/Info.plist"
          /usr/libexec/PlistBuddy -c "Set :ApplicationProperties:CFBundleVersion $BUILD_NUMBER" "$ARCHIVE_PATH/Info.plist"

      - name: Export IPA
        id: export
        env:
          ARCHIVE_PATH: ${{ steps.app-info.outputs.archive-path }}
          KEYCHAIN_NAME: ${{ steps.keychain.outputs.keychain-name }}
          TEAM_ID: ${{ steps.signing.outputs.team-id }}
          PROFILE_NAME: ${{ steps.signing.outputs.profile-name }}
          BUNDLE_ID: ${{ steps.app-info.outputs.bundle-id }}
        run: |
          cat > export.plist <<EOF
          <?xml version="1.0" encoding="UTF-8"?>
          <!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
          <plist version="1.0">
          <dict>
            <key>method</key><string>app-store-connect</string>
            <key>signingStyle</key><string>manual</string>
            <key>teamID</key><string>$TEAM_ID</string>
            <key>provisioningProfiles</key>
            <dict>
              <key>$BUNDLE_ID</key><string>$PROFILE_NAME</string>
            </dict>
            <key>signingCertificate</key><string>Apple Distribution</string>
            <key>compileBitcode</key><false/>
            <key>uploadSymbols</key><true/>
          </dict>
          </plist>
          EOF

          export OTHER_CODE_SIGN_FLAGS="--keychain $KEYCHAIN_NAME"

          rm -rf _export && mkdir _export
          xcodebuild -exportArchive \
            -archivePath "$ARCHIVE_PATH" \
            -exportOptionsPlist export.plist \
            -exportPath _export

          ipa=$(find _export -name "*.ipa" | head -1)
          echo "ipa-path=$ipa" >> $GITHUB_OUTPUT

      - name: Upload to TestFlight
        env:
          IPA_PATH: ${{ steps.export.outputs.ipa-path }}
          APP_STORE_CONNECT_API_KEY_ID: ${{ secrets.APP_STORE_CONNECT_API_KEY_ID }}
          APP_STORE_CONNECT_API_KEY_ISSUER_ID: ${{ secrets.APP_STORE_CONNECT_API_KEY_ISSUER_ID }}
          APP_STORE_CONNECT_API_KEY_P8: ${{ secrets.APP_STORE_CONNECT_API_KEY_P8 }}
          CHANGELOG: ${{ steps.changelog.outputs.changelog }}
        run: |
          api_key="{ \"key_id\": \"$APP_STORE_CONNECT_API_KEY_ID\", \"issuer_id\": \"$APP_STORE_CONNECT_API_KEY_ISSUER_ID\", \"key\": $(echo "$APP_STORE_CONNECT_API_KEY_P8" | jq -Rs .) }"

          fastlane pilot upload \
            --ipa "$IPA_PATH" \
            --api_key "$api_key" \
            --skip_submission true \
            --skip_waiting_for_build_processing true \
            --distribute_external false \
            --changelog "$CHANGELOG"

      - name: Cleanup Keychain
        if: always()
        env:
          KEYCHAIN_NAME: ${{ steps.keychain.outputs.keychain-name }}
        run: |
          security delete-keychain "$KEYCHAIN_NAME" || true

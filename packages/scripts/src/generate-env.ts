#!/usr/bin/env bun

import fs from 'node:fs'

import { cmd } from './cmd'
import { resolveDepVersion } from './helpers/resolve-dep-version'

await cmd`sync auto-generated env vars to local .env file`.run(async ({ path }) => {
  const ENV_PATH = path.join(process.cwd(), '.env')
  const ENV_BACKUP_PATH = path.join(process.cwd(), '.env.backup')
  const ENV_TEMP_PATH = path.join(process.cwd(), '.env.tmp')

  // auto-generated section markers
  const BEGIN_MARKER = '# ---- BEGIN AUTO-GENERATED (DO NOT EDIT) ----'
  const END_MARKER = '# ---- END AUTO-GENERATED ----'

  function getAutoGeneratedContent(): string {
    const packageJsonPath = path.join(process.cwd(), 'package.json')
    const packageJson = JSON.parse(fs.readFileSync(packageJsonPath, 'utf-8'))
    const envVars = packageJson.env as Record<string, boolean | string>

    if (!envVars || typeof envVars !== 'object') {
      console.warn('No env section found in package.json')
      return ''
    }

    const lines: string[] = [BEGIN_MARKER, `# Generated at: ${new Date().toISOString()}`]

    for (const [key, value] of Object.entries(envVars)) {
      const depVersion = resolveDepVersion(value, packageJson.dependencies)
      if (depVersion) {
        lines.push(`${key}=${depVersion}`)
      } else if (typeof value === 'string' && value.startsWith('$dep:')) {
        console.warn(
          `Could not resolve dependency version for ${value.slice('$dep:'.length)}`
        )
      } else if (typeof value === 'string' && value !== '') {
        // non-empty string default
        lines.push(`${key}=${value}`)
      }
      // skip true (required, no default) and "" (no meaningful default)
    }

    lines.push(END_MARKER)
    return lines.join('\n')
  }

  function updateEnvFile(): void {
    // ensure .env exists
    if (!fs.existsSync(ENV_PATH)) {
      fs.writeFileSync(ENV_PATH, '')
      console.info('Created empty .env file')
    }

    try {
      // create backup
      if (fs.existsSync(ENV_PATH)) {
        fs.copyFileSync(ENV_PATH, ENV_BACKUP_PATH)
      }

      const currentContent = fs.readFileSync(ENV_PATH, 'utf-8')

      const beginIndex = currentContent.indexOf(BEGIN_MARKER)
      const endIndex = currentContent.indexOf(END_MARKER)

      let newContent: string

      if (beginIndex !== -1 && endIndex !== -1 && endIndex > beginIndex) {
        // replace existing auto-generated section
        const beforeSection = currentContent.substring(0, beginIndex).trimEnd()
        const afterSection = currentContent
          .substring(endIndex + END_MARKER.length)
          .trimStart()

        newContent = [beforeSection, getAutoGeneratedContent(), afterSection]
          .filter(Boolean)
          .join('\n\n')
      } else if (beginIndex !== -1 || endIndex !== -1) {
        // malformed markers - preserve content and append new section
        console.warn('Found malformed auto-generated section, appending new section')
        newContent = currentContent.trimEnd() + '\n\n' + getAutoGeneratedContent()
      } else {
        // no existing section - append to end
        const trimmedContent = currentContent.trimEnd()
        newContent = trimmedContent
          ? trimmedContent + '\n\n' + getAutoGeneratedContent()
          : getAutoGeneratedContent()
      }

      // write to temp file first (atomic operation)
      fs.writeFileSync(ENV_TEMP_PATH, newContent)

      // validate temp file
      const tempContent = fs.readFileSync(ENV_TEMP_PATH, 'utf-8')
      if (!tempContent.includes(BEGIN_MARKER) || !tempContent.includes(END_MARKER)) {
        throw new Error('Generated content validation failed')
      }

      // atomic replace
      fs.renameSync(ENV_TEMP_PATH, ENV_PATH)

      if (fs.existsSync(ENV_BACKUP_PATH)) {
        try {
          fs.unlinkSync(ENV_BACKUP_PATH)
        } catch {
          // ignore cleanup errors
        }
      }

      console.info('Updated .env auto-generated section')
    } catch (error) {
      console.error('Failed to update .env file:', error)

      // attempt to restore backup
      if (fs.existsSync(ENV_BACKUP_PATH)) {
        try {
          fs.copyFileSync(ENV_BACKUP_PATH, ENV_PATH)
          console.info('Restored .env from backup')
        } catch (restoreError) {
          console.error('Failed to restore backup:', restoreError)
        }
      }

      // clean up temp file
      if (fs.existsSync(ENV_TEMP_PATH)) {
        try {
          fs.unlinkSync(ENV_TEMP_PATH)
        } catch {
          // ignore cleanup errors
        }
      }

      // don't fail the install process
      process.exit(0)
    }
  }

  try {
    updateEnvFile()
  } catch (error) {
    // catch any unexpected errors and exit gracefully
    console.error('Bootstrap script error:', error)
    process.exit(0)
  }
})

---
title: Agents
description: AI-powered development with Takeout
---

Takeout treats agent-readability as a first-class concern. The codebase is
structured so AI coding agents can understand patterns, find examples, and
verify their work without constant hand-holding.

The result: describe what you want, and agents can often implement features
end-to-end—data layer, UI, permissions, tests—using the patterns already in
place.

## Skills

Skills are instruction sets that teach agents how to work in this codebase. They
live in `.claude/skills/` and map to docs in `docs/` and `packages/docs/`.

When an agent starts a session, it loads the core guidelines automatically. When
working on a feature, it can pull in relevant skills—say, `takeout-zero` when
adding a synced data type, or `takeout-triggers` when setting up database
automation.

Each skill includes:

- the pattern and why it exists
- working examples from the codebase
- common mistakes to avoid
- verification steps

This means agents don't guess at conventions. They look up the skill, follow the
pattern, and produce code that fits.

### Available Skills

| Skill                                  | Description                                     | Tier |
| -------------------------------------- | ----------------------------------------------- | ---- |
| `takeout-takeout`                      | General overview and getting started            | Free |
| `takeout-tamagui`                      | UI framework, tokens, themes, responsive design | Free |
| `takeout-zero`                         | Data sync, queries, mutations, permissions      | Free |
| `takeout-one-routes`                   | File-based routing, SSG/SSR, loaders            | Pro  |
| `takeout-one-hooks`                    | useRouter, useParams, useLoader, navigation     | Pro  |
| `takeout-one-components`               | Link, Head, SafeAreaView, layouts               | Pro  |
| `takeout-database`                     | PostgreSQL, Drizzle ORM, migrations             | Pro  |
| `takeout-aggregates`                   | Denormalized counts via triggers                | Pro  |
| `takeout-triggers`                     | PostgreSQL trigger automation                   | Pro  |
| `takeout-emitters`                     | Event pub/sub for ephemeral UI state            | Pro  |
| `takeout-testing-integration`          | Playwright e2e tests                            | Pro  |
| `takeout-scripts`                      | tko CLI and automation                          | Pro  |
| `takeout-package-json`                 | Workspace and script configuration              | Pro  |
| `takeout-sync-prompt`                  | Merging upstream Takeout changes                | Pro  |
| `takeout-react-native-navigation-flow` | Mobile routing patterns                         | Pro  |
| `takeout-hot-updater`                  | OTA updates for React Native                    | Pro  |
| `takeout-native-hot-update`            | Hot update splash and deployment                | Pro  |
| `takeout-xcodebuild-mcp`               | iOS debugging and simulator tools               | Pro  |
| `takeout-cloudflare-dev-tunnel`        | Expose local dev publicly                       | Pro  |
| `deploy`                               | Deployment infrastructure overview              | Pro  |
| `deploy-uncloud`                       | Self-hosted production setup                    | Pro  |
| `add-icon`                             | Managing Phosphor icons                         | Pro  |
| `commit`                               | Git commit conventions                          | Pro  |

## On-zero

The [on-zero](https://github.com/onejs/on-zero) package structures your data
layer in a way that's easy for both humans and agents to understand. Models
define schema, permissions, and mutations together. Queries are plain functions
that become synced automatically.

When an agent needs to add a new data type, the pattern is clear:

1. create the model in `src/data/models/`
2. add queries in `src/data/queries/`
3. run `bun zero/generate` to get types
4. use the generated hooks in your UI

There's no ambiguity about where things go or how permissions work. Agents can
implement features involving offline sync, optimistic updates, and row-level
security without needing to figure out the architecture.

See the [Zero docs](/docs/zero) for the full picture.

## Scripts

The `tko` CLI gives agents (and you) a discoverable set of operations. Run
`bun tko` to see what's available:

```bash
bun tko              # list all scripts
bun tko check types  # run type checking
bun tko web build    # build for web
```

Scripts are organized by category—`check/`, `ops/`, `web/`, `db/`—so agents can
find the right tool without asking.

## Verification

Session hooks ensure agents know to verify their work. The core guidelines load
automatically and include explicit verification steps—run `bun check:all` for
quick checks, `bun ops release --dry-run` for the full pipeline (see
[Releasing](/docs/releasing) for details).

```bash
bun check:all        # types, lint, tests
bun ops release --dry-run # full CI pipeline locally
```

This catches issues early. When an agent says "done," you can trust the tests
passed and types check.

## What This Enables

A typical agent workflow:

1. You describe a feature ("add a favorites system")
2. Agent checks relevant skills (zero, triggers, routes)
3. Implements using established patterns
4. Runs verification
5. You review working code

The structure removes guesswork.
